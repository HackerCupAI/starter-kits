# Sample data-only solver

This directory contains a very simple baseline solver for the Hacker Cup problems
that uses only the problem's sample input/output - the actual problem statement is
completely ignored.

The purpose of this example solver is to show the dataset file structure and demonstrate
that some (very bad) results can be achieved just by looking at the sample data.

How it works: start a function definition `def f(a):`, append sample input/output
as doctests, and use Code LLama to complete the function.

Currently the solver only attempts to solve problems where each sample corresponds to
one input line and one output line.

## Installation

Run `pip install -r requirements.txt`. You should already have NVidia drivers and
CUDA installed.

## Download data

Run `python download_dataset.py`. This will download inputs and outputs from
"hackercupai/hackercup" Hugging Face dataset into `dataset` directory. Currently the script
will fail because of some problems with the dataset, but it will download enough data for
a demo.

## Generate programs

Run `python generate_programs.py`. This will generate programs and save them to `programs`
directory. You can adjust `MAX_NEW_TOKENS` and `MAX_TIME` per program to control generation
time. You can stop the script midway with Ctrl-C if you want only a couple of programs generated.

Here is an example of a generated program (note that only the body of `f` was generated by LLM):

```Python
def f(a):
    """Returns solution
    >>> f(['facebook', 'hacker', 'cup', 'for', 'studious', 'students'])
    cupfacebookforhackerstudentsstudious
    >>> f(['k', 'duz', 'q', 'rc', 'lvraw'])
    duzklvrawqrc
    >>> f(['mybea', 'zdr', 'yubx', 'xe', 'dyroiy'])
    dyroiymybeaxeyubxzdr
    >>> f(['jibw', 'ji', 'jp', 'bw', 'jibw'])
    bwjibwjibwjijp
    >>> f(['uiuy', 'hopji', 'li', 'j', 'dcyi'])
    dcyihopjijliuiuy
    """
    a.sort()
    return ''.join(a)

T = int(input())
for case_num in range(1, T + 1):
    a = input().split()
    for i in range(len(a)):
        try:
            a[i] = float(a[i])
        except ValueError:
            pass
        try:
            a[i] = int(a[i])
        except ValueError:
            pass
    if len(a) == 1:
        a = a[0]
    else:
        # Simplify when first item is number of strings in list
        if isinstance(a[0], int) and isinstance(a[1], str):
            if (len(a) - 1) == a[0]:
                a = a[1:]
    print(f"Case #{case_num}: {f(a)}")
```

Generated programs are sampled, and are therefore non-deterministic unless a random seed is set.

## Evaluate programs

For security reasons, you should look at the generated programs before running them.
It's very unlikely that a malicious program will be generated, but it's theoretically possible.

Run `python evaluate_programs.py`. This will find all the programs in the `programs` dir,
run them on the inputs, and compare the results to the outputs in the `dataset` dir.

Here is a result of a short test run (FAIL means generated program was not valid -
most likely because `MAX_NEW_TOKENS` or `MAX_TIME` were too low):

| Problem | Score |
| ------- | ----- |
| 2011/quals/double_squares | 2/63 |
| 2011/quals/studious_student | 21/39 |
| 2011/quals/peg_game | FAIL |
| 2011/round1a/wine_tasting | 2/50 |
| 2011/round1b/diminishing_circle | 0/60 |
| 2011/round1b/slot_machine_hacker | FAIL |
| 2011/round1c/n_factorful | 15/50 |
