# Sample data-only solver

This directory contains a very simple baseline solver for the Hacker Cup problems
that uses only the problem's sample input/output - the actual problem statement is
completely ignored.

The purpose of this example solver is to show the dataset file structure and demonstrate
that some (very bad) results can be achieved just by looking at the sample data.

How it works: start a function definition `def f(a):`, append sample input/output
as doctests, and use Code LLama to complete the function.

Currently the solver only attempts to solve problems where each sample corresponds to
one input line and one output line.

## Installation

Run `pip install -r requirements.txt`. You should already have NVidia drivers and
CUDA installed.

## Download data

```
git clone https://huggingface.co/datasets/hackercupai/hackercup ./dataset
```
This will download raw inputs and outputs files from the "hackercupai/hackercup" Hugging Face dataset 
into a `dataset` directory. This command currently throws an error, but still downloads all of 
the files correctly.

Alternatively, you can run `python download_dataset.py`. This will also download inputs and outputs from
"hackercupai/hackercup" Hugging Face dataset into `dataset` directory. Currently the script
errors due to issues with the HuggingFace upload but will likely be fixed soon.

## Generate programs

Run `python generate_programs.py`. This will generate programs and save them to `programs`
directory. You can adjust `MAX_NEW_TOKENS` and `MAX_TIME` per program to control generation
time. You can stop the script midway with Ctrl-C if you want only a couple of programs generated.

Here is an example of a generated program. Only the body of `f` was generated by LLM:

```Python
def f(a):
    """Returns solution
    >>> f(['facebook', 'hacker', 'cup', 'for', 'studious', 'students'])
    cupfacebookforhackerstudentsstudious
    >>> f(['k', 'duz', 'q', 'rc', 'lvraw'])
    duzklvrawqrc
    >>> f(['mybea', 'zdr', 'yubx', 'xe', 'dyroiy'])
    dyroiymybeaxeyubxzdr
    >>> f(['jibw', 'ji', 'jp', 'bw', 'jibw'])
    bwjibwjibwjijp
    >>> f(['uiuy', 'hopji', 'li', 'j', 'dcyi'])
    dcyihopjijliuiuy
    """
    a.sort()
    return ''.join(a)

T = int(input())
for case_num in range(1, T + 1):
    a = input().split()
    for i in range(len(a)):
        try:
            a[i] = float(a[i])
        except ValueError:
            pass
        try:
            a[i] = int(a[i])
        except ValueError:
            pass
    if len(a) == 1:
        a = a[0]
    else:
        if isinstance(a[0], int) and isinstance(a[1], str):
            if (len(a) - 1) == a[0]:
                a = a[1:]
    print(f"Case #{case_num}: {f(a)}")

```

Generated programs are sampled, and are therefore non-deterministic unless a random seed is set. 
You can use arguments to `pipeline()` to use greedy generation, change top-p or top-k values, set 
the temperature, and alter various other hyperparameters.

## Evaluate programs

For security reasons, you should look at the generated programs before running them.
It's very unlikely that a malicious program will be generated, but it's theoretically possible.

Run `python evaluate_programs.py`. This will find all the programs in the `programs` dir,
run them on the inputs, and compare the results to the outputs in the `dataset` dir.

Here is a result of a short test run (FAIL means generated program was not valid -
most likely because `MAX_NEW_TOKENS` or `MAX_TIME` were too low):

| Problem | Score |
| ------- | ----- |
| 2011/quals/double_squares | 2/63 |
| 2011/quals/peg_game | FAIL |
| 2011/quals/studious_student | 21/39 |
| 2011/round1a/wine_tasting | FAIL |
| 2011/round1b/diminishing_circle | 3/60 |
| 2011/round1b/slot_machine_hacker | 0/55 |
| 2011/round1c/n_factorful | 1/50 |
